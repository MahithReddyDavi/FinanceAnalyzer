{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ResponseStream_instances, _ResponseStream_params, _ResponseStream_currentResponseSnapshot, _ResponseStream_finalResponse, _ResponseStream_beginRequest, _ResponseStream_addEvent, _ResponseStream_endRequest, _ResponseStream_accumulateResponse;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ResponseStream = void 0;\nconst error_1 = require(\"../../error.js\");\nconst EventStream_1 = require(\"../EventStream.js\");\nconst ResponsesParser_1 = require(\"../ResponsesParser.js\");\nclass ResponseStream extends EventStream_1.EventStream {\n  constructor(params) {\n    super();\n    _ResponseStream_instances.add(this);\n    _ResponseStream_params.set(this, void 0);\n    _ResponseStream_currentResponseSnapshot.set(this, void 0);\n    _ResponseStream_finalResponse.set(this, void 0);\n    __classPrivateFieldSet(this, _ResponseStream_params, params, \"f\");\n  }\n  static createResponse(client, params, options) {\n    const runner = new ResponseStream(params);\n    runner._run(() => runner._createResponse(client, params, {\n      ...options,\n      headers: {\n        ...options?.headers,\n        'X-Stainless-Helper-Method': 'stream'\n      }\n    }));\n    return runner;\n  }\n  async _createResponse(client, params, options) {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    __classPrivateFieldGet(this, _ResponseStream_instances, \"m\", _ResponseStream_beginRequest).call(this);\n    const stream = await client.responses.create({\n      ...params,\n      stream: true\n    }, {\n      ...options,\n      signal: this.controller.signal\n    });\n    this._connected();\n    for await (const event of stream) {\n      __classPrivateFieldGet(this, _ResponseStream_instances, \"m\", _ResponseStream_addEvent).call(this, event);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new error_1.APIUserAbortError();\n    }\n    return __classPrivateFieldGet(this, _ResponseStream_instances, \"m\", _ResponseStream_endRequest).call(this);\n  }\n  [(_ResponseStream_params = new WeakMap(), _ResponseStream_currentResponseSnapshot = new WeakMap(), _ResponseStream_finalResponse = new WeakMap(), _ResponseStream_instances = new WeakSet(), _ResponseStream_beginRequest = function _ResponseStream_beginRequest() {\n    if (this.ended) return;\n    __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, undefined, \"f\");\n  }, _ResponseStream_addEvent = function _ResponseStream_addEvent(event) {\n    if (this.ended) return;\n    const response = __classPrivateFieldGet(this, _ResponseStream_instances, \"m\", _ResponseStream_accumulateResponse).call(this, event);\n    this._emit('event', event);\n    switch (event.type) {\n      case 'response.output_text.delta':\n        {\n          const output = response.output[event.output_index];\n          if (!output) {\n            throw new error_1.OpenAIError(`missing output at index ${event.output_index}`);\n          }\n          if (output.type === 'message') {\n            const content = output.content[event.content_index];\n            if (!content) {\n              throw new error_1.OpenAIError(`missing content at index ${event.content_index}`);\n            }\n            if (content.type !== 'output_text') {\n              throw new error_1.OpenAIError(`expected content to be 'output_text', got ${content.type}`);\n            }\n            this._emit('response.output_text.delta', {\n              ...event,\n              snapshot: content.text\n            });\n          }\n          break;\n        }\n      case 'response.function_call_arguments.delta':\n        {\n          const output = response.output[event.output_index];\n          if (!output) {\n            throw new error_1.OpenAIError(`missing output at index ${event.output_index}`);\n          }\n          if (output.type === 'function_call') {\n            this._emit('response.function_call_arguments.delta', {\n              ...event,\n              snapshot: output.arguments\n            });\n          }\n          break;\n        }\n      default:\n        // @ts-ignore\n        this._emit(event.type, event);\n        break;\n    }\n  }, _ResponseStream_endRequest = function _ResponseStream_endRequest() {\n    if (this.ended) {\n      throw new error_1.OpenAIError(`stream has ended, this shouldn't happen`);\n    }\n    const snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, \"f\");\n    if (!snapshot) {\n      throw new error_1.OpenAIError(`request ended without sending any events`);\n    }\n    __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, undefined, \"f\");\n    const parsedResponse = finalizeResponse(snapshot, __classPrivateFieldGet(this, _ResponseStream_params, \"f\"));\n    __classPrivateFieldSet(this, _ResponseStream_finalResponse, parsedResponse, \"f\");\n    return parsedResponse;\n  }, _ResponseStream_accumulateResponse = function _ResponseStream_accumulateResponse(event) {\n    let snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, \"f\");\n    if (!snapshot) {\n      if (event.type !== 'response.created') {\n        throw new error_1.OpenAIError(`When snapshot hasn't been set yet, expected 'response.created' event, got ${event.type}`);\n      }\n      snapshot = __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, \"f\");\n      return snapshot;\n    }\n    switch (event.type) {\n      case 'response.output_item.added':\n        {\n          snapshot.output.push(event.item);\n          break;\n        }\n      case 'response.content_part.added':\n        {\n          const output = snapshot.output[event.output_index];\n          if (!output) {\n            throw new error_1.OpenAIError(`missing output at index ${event.output_index}`);\n          }\n          if (output.type === 'message') {\n            output.content.push(event.part);\n          }\n          break;\n        }\n      case 'response.output_text.delta':\n        {\n          const output = snapshot.output[event.output_index];\n          if (!output) {\n            throw new error_1.OpenAIError(`missing output at index ${event.output_index}`);\n          }\n          if (output.type === 'message') {\n            const content = output.content[event.content_index];\n            if (!content) {\n              throw new error_1.OpenAIError(`missing content at index ${event.content_index}`);\n            }\n            if (content.type !== 'output_text') {\n              throw new error_1.OpenAIError(`expected content to be 'output_text', got ${content.type}`);\n            }\n            content.text += event.delta;\n          }\n          break;\n        }\n      case 'response.function_call_arguments.delta':\n        {\n          const output = snapshot.output[event.output_index];\n          if (!output) {\n            throw new error_1.OpenAIError(`missing output at index ${event.output_index}`);\n          }\n          if (output.type === 'function_call') {\n            output.arguments += event.delta;\n          }\n          break;\n        }\n      case 'response.completed':\n        {\n          __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, \"f\");\n          break;\n        }\n    }\n    return snapshot;\n  }, Symbol.asyncIterator)]() {\n    const pushQueue = [];\n    const readQueue = [];\n    let done = false;\n    this.on('event', event => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader.resolve(event);\n      } else {\n        pushQueue.push(event);\n      }\n    });\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.resolve(undefined);\n      }\n      readQueue.length = 0;\n    });\n    this.on('abort', err => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n    this.on('error', err => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n    return {\n      next: async () => {\n        if (!pushQueue.length) {\n          if (done) {\n            return {\n              value: undefined,\n              done: true\n            };\n          }\n          return new Promise((resolve, reject) => readQueue.push({\n            resolve,\n            reject\n          })).then(event => event ? {\n            value: event,\n            done: false\n          } : {\n            value: undefined,\n            done: true\n          });\n        }\n        const event = pushQueue.shift();\n        return {\n          value: event,\n          done: false\n        };\n      },\n      return: async () => {\n        this.abort();\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n    };\n  }\n  /**\n   * @returns a promise that resolves with the final Response, or rejects\n   * if an error occurred or the stream ended prematurely without producing a REsponse.\n   */\n  async finalResponse() {\n    await this.done();\n    const response = __classPrivateFieldGet(this, _ResponseStream_finalResponse, \"f\");\n    if (!response) throw new error_1.OpenAIError('stream ended without producing a ChatCompletion');\n    return response;\n  }\n}\nexports.ResponseStream = ResponseStream;\nfunction finalizeResponse(snapshot, params) {\n  return (0, ResponsesParser_1.maybeParseResponse)(snapshot, params);\n}","map":{"version":3,"names":["error_1","require","EventStream_1","ResponsesParser_1","ResponseStream","EventStream","constructor","params","_ResponseStream_params","set","_ResponseStream_currentResponseSnapshot","_ResponseStream_finalResponse","__classPrivateFieldSet","createResponse","client","options","runner","_run","_createResponse","headers","signal","aborted","controller","abort","addEventListener","__classPrivateFieldGet","_ResponseStream_instances","_ResponseStream_beginRequest","call","stream","responses","create","_connected","event","_ResponseStream_addEvent","APIUserAbortError","_ResponseStream_endRequest","WeakMap","WeakSet","ended","undefined","response","_ResponseStream_accumulateResponse","_emit","type","output","output_index","OpenAIError","content","content_index","snapshot","text","arguments","parsedResponse","finalizeResponse","push","item","part","delta","Symbol","asyncIterator","pushQueue","readQueue","done","on","reader","shift","resolve","length","err","reject","next","value","Promise","then","return","finalResponse","exports","maybeParseResponse"],"sources":["C:\\Users\\uppal\\OneDrive\\Desktop\\financial assistant\\frontend\\node_modules\\openai\\src\\lib\\responses\\ResponseStream.ts"],"sourcesContent":["import {\n  type ParsedResponse,\n  type Response,\n  type ResponseCreateParamsBase,\n  type ResponseCreateParamsStreaming,\n  type ResponseStreamEvent,\n} from '../../resources/responses/responses';\nimport * as Core from '../../core';\nimport { APIUserAbortError, OpenAIError } from '../../error';\nimport OpenAI from '../../index';\nimport { type BaseEvents, EventStream } from '../EventStream';\nimport { type ResponseFunctionCallArgumentsDeltaEvent, type ResponseTextDeltaEvent } from './EventTypes';\nimport { maybeParseResponse } from '../ResponsesParser';\n\nexport type ResponseStreamParams = Omit<ResponseCreateParamsBase, 'stream'> & {\n  stream?: true;\n};\n\ntype ResponseEvents = BaseEvents &\n  Omit<\n    {\n      [K in ResponseStreamEvent['type']]: (event: Extract<ResponseStreamEvent, { type: K }>) => void;\n    },\n    'response.output_text.delta' | 'response.function_call_arguments.delta'\n  > & {\n    event: (event: ResponseStreamEvent) => void;\n    'response.output_text.delta': (event: ResponseTextDeltaEvent) => void;\n    'response.function_call_arguments.delta': (event: ResponseFunctionCallArgumentsDeltaEvent) => void;\n  };\n\nexport type ResponseStreamingParams = Omit<ResponseCreateParamsBase, 'stream'> & {\n  stream?: true;\n};\n\nexport class ResponseStream<ParsedT = null>\n  extends EventStream<ResponseEvents>\n  implements AsyncIterable<ResponseStreamEvent>\n{\n  #params: ResponseStreamingParams | null;\n  #currentResponseSnapshot: Response | undefined;\n  #finalResponse: ParsedResponse<ParsedT> | undefined;\n\n  constructor(params: ResponseStreamingParams | null) {\n    super();\n    this.#params = params;\n  }\n\n  static createResponse<ParsedT>(\n    client: OpenAI,\n    params: ResponseStreamParams,\n    options?: Core.RequestOptions,\n  ): ResponseStream<ParsedT> {\n    const runner = new ResponseStream<ParsedT>(params as ResponseCreateParamsStreaming);\n    runner._run(() =>\n      runner._createResponse(client, params, {\n        ...options,\n        headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' },\n      }),\n    );\n    return runner;\n  }\n\n  #beginRequest() {\n    if (this.ended) return;\n    this.#currentResponseSnapshot = undefined;\n  }\n\n  #addEvent(this: ResponseStream<ParsedT>, event: ResponseStreamEvent) {\n    if (this.ended) return;\n\n    const response = this.#accumulateResponse(event);\n    this._emit('event', event);\n\n    switch (event.type) {\n      case 'response.output_text.delta': {\n        const output = response.output[event.output_index];\n        if (!output) {\n          throw new OpenAIError(`missing output at index ${event.output_index}`);\n        }\n        if (output.type === 'message') {\n          const content = output.content[event.content_index];\n          if (!content) {\n            throw new OpenAIError(`missing content at index ${event.content_index}`);\n          }\n          if (content.type !== 'output_text') {\n            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);\n          }\n\n          this._emit('response.output_text.delta', {\n            ...event,\n            snapshot: content.text,\n          });\n        }\n        break;\n      }\n      case 'response.function_call_arguments.delta': {\n        const output = response.output[event.output_index];\n        if (!output) {\n          throw new OpenAIError(`missing output at index ${event.output_index}`);\n        }\n        if (output.type === 'function_call') {\n          this._emit('response.function_call_arguments.delta', {\n            ...event,\n            snapshot: output.arguments,\n          });\n        }\n        break;\n      }\n      default:\n        // @ts-ignore\n        this._emit(event.type, event);\n        break;\n    }\n  }\n\n  #endRequest(): ParsedResponse<ParsedT> {\n    if (this.ended) {\n      throw new OpenAIError(`stream has ended, this shouldn't happen`);\n    }\n    const snapshot = this.#currentResponseSnapshot;\n    if (!snapshot) {\n      throw new OpenAIError(`request ended without sending any events`);\n    }\n    this.#currentResponseSnapshot = undefined;\n    const parsedResponse = finalizeResponse<ParsedT>(snapshot, this.#params);\n    this.#finalResponse = parsedResponse;\n\n    return parsedResponse;\n  }\n\n  protected async _createResponse(\n    client: OpenAI,\n    params: ResponseStreamingParams,\n    options?: Core.RequestOptions,\n  ): Promise<ParsedResponse<ParsedT>> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#beginRequest();\n\n    const stream = await client.responses.create(\n      { ...params, stream: true },\n      { ...options, signal: this.controller.signal },\n    );\n    this._connected();\n    for await (const event of stream) {\n      this.#addEvent(event);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    return this.#endRequest();\n  }\n\n  #accumulateResponse(event: ResponseStreamEvent): Response {\n    let snapshot = this.#currentResponseSnapshot;\n    if (!snapshot) {\n      if (event.type !== 'response.created') {\n        throw new OpenAIError(\n          `When snapshot hasn't been set yet, expected 'response.created' event, got ${event.type}`,\n        );\n      }\n      snapshot = this.#currentResponseSnapshot = event.response;\n      return snapshot;\n    }\n\n    switch (event.type) {\n      case 'response.output_item.added': {\n        snapshot.output.push(event.item);\n        break;\n      }\n      case 'response.content_part.added': {\n        const output = snapshot.output[event.output_index];\n        if (!output) {\n          throw new OpenAIError(`missing output at index ${event.output_index}`);\n        }\n        if (output.type === 'message') {\n          output.content.push(event.part);\n        }\n        break;\n      }\n      case 'response.output_text.delta': {\n        const output = snapshot.output[event.output_index];\n        if (!output) {\n          throw new OpenAIError(`missing output at index ${event.output_index}`);\n        }\n        if (output.type === 'message') {\n          const content = output.content[event.content_index];\n          if (!content) {\n            throw new OpenAIError(`missing content at index ${event.content_index}`);\n          }\n          if (content.type !== 'output_text') {\n            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);\n          }\n          content.text += event.delta;\n        }\n        break;\n      }\n      case 'response.function_call_arguments.delta': {\n        const output = snapshot.output[event.output_index];\n        if (!output) {\n          throw new OpenAIError(`missing output at index ${event.output_index}`);\n        }\n        if (output.type === 'function_call') {\n          output.arguments += event.delta;\n        }\n        break;\n      }\n      case 'response.completed': {\n        this.#currentResponseSnapshot = event.response;\n        break;\n      }\n    }\n\n    return snapshot;\n  }\n\n  [Symbol.asyncIterator](this: ResponseStream<ParsedT>): AsyncIterator<ResponseStreamEvent> {\n    const pushQueue: ResponseStreamEvent[] = [];\n    const readQueue: {\n      resolve: (event: ResponseStreamEvent | undefined) => void;\n      reject: (err: unknown) => void;\n    }[] = [];\n    let done = false;\n\n    this.on('event', (event) => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader.resolve(event);\n      } else {\n        pushQueue.push(event);\n      }\n    });\n\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.resolve(undefined);\n      }\n      readQueue.length = 0;\n    });\n\n    this.on('abort', (err) => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n\n    this.on('error', (err) => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n\n    return {\n      next: async (): Promise<IteratorResult<ResponseStreamEvent>> => {\n        if (!pushQueue.length) {\n          if (done) {\n            return { value: undefined, done: true };\n          }\n          return new Promise<ResponseStreamEvent | undefined>((resolve, reject) =>\n            readQueue.push({ resolve, reject }),\n          ).then((event) => (event ? { value: event, done: false } : { value: undefined, done: true }));\n        }\n        const event = pushQueue.shift()!;\n        return { value: event, done: false };\n      },\n      return: async () => {\n        this.abort();\n        return { value: undefined, done: true };\n      },\n    };\n  }\n\n  /**\n   * @returns a promise that resolves with the final Response, or rejects\n   * if an error occurred or the stream ended prematurely without producing a REsponse.\n   */\n  async finalResponse(): Promise<ParsedResponse<ParsedT>> {\n    await this.done();\n    const response = this.#finalResponse;\n    if (!response) throw new OpenAIError('stream ended without producing a ChatCompletion');\n    return response;\n  }\n}\n\nfunction finalizeResponse<ParsedT>(\n  snapshot: Response,\n  params: ResponseStreamingParams | null,\n): ParsedResponse<ParsedT> {\n  return maybeParseResponse(snapshot, params);\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAQA,MAAAA,OAAA,GAAAC,OAAA;AAEA,MAAAC,aAAA,GAAAD,OAAA;AAEA,MAAAE,iBAAA,GAAAF,OAAA;AAsBA,MAAaG,cACX,SAAQF,aAAA,CAAAG,WAA2B;EAOnCC,YAAYC,MAAsC;IAChD,KAAK,EAAE;;IALTC,sBAAA,CAAAC,GAAA;IACAC,uCAAA,CAAAD,GAAA;IACAE,6BAAA,CAAAF,GAAA;IAIEG,sBAAA,KAAI,EAAAJ,sBAAA,EAAWD,MAAM;EACvB;EAEA,OAAOM,cAAcA,CACnBC,MAAc,EACdP,MAA4B,EAC5BQ,OAA6B;IAE7B,MAAMC,MAAM,GAAG,IAAIZ,cAAc,CAAUG,MAAuC,CAAC;IACnFS,MAAM,CAACC,IAAI,CAAC,MACVD,MAAM,CAACE,eAAe,CAACJ,MAAM,EAAEP,MAAM,EAAE;MACrC,GAAGQ,OAAO;MACVI,OAAO,EAAE;QAAE,GAAGJ,OAAO,EAAEI,OAAO;QAAE,2BAA2B,EAAE;MAAQ;KACtE,CAAC,CACH;IACD,OAAOH,MAAM;EACf;EAsEU,MAAME,eAAeA,CAC7BJ,MAAc,EACdP,MAA+B,EAC/BQ,OAA6B;IAE7B,MAAMK,MAAM,GAAGL,OAAO,EAAEK,MAAM;IAC9B,IAAIA,MAAM,EAAE;MACV,IAAIA,MAAM,CAACC,OAAO,EAAE,IAAI,CAACC,UAAU,CAACC,KAAK,EAAE;MAC3CH,MAAM,CAACI,gBAAgB,CAAC,OAAO,EAAE,MAAM,IAAI,CAACF,UAAU,CAACC,KAAK,EAAE,CAAC;;IAEjEE,sBAAA,KAAI,EAAAC,yBAAA,OAAAC,4BAAA,CAAc,CAAAC,IAAA,CAAlB,IAAI,CAAgB;IAEpB,MAAMC,MAAM,GAAG,MAAMf,MAAM,CAACgB,SAAS,CAACC,MAAM,CAC1C;MAAE,GAAGxB,MAAM;MAAEsB,MAAM,EAAE;IAAI,CAAE,EAC3B;MAAE,GAAGd,OAAO;MAAEK,MAAM,EAAE,IAAI,CAACE,UAAU,CAACF;IAAM,CAAE,CAC/C;IACD,IAAI,CAACY,UAAU,EAAE;IACjB,WAAW,MAAMC,KAAK,IAAIJ,MAAM,EAAE;MAChCJ,sBAAA,KAAI,EAAAC,yBAAA,OAAAQ,wBAAA,CAAU,CAAAN,IAAA,CAAd,IAAI,EAAWK,KAAK,CAAC;;IAEvB,IAAIJ,MAAM,CAACP,UAAU,CAACF,MAAM,EAAEC,OAAO,EAAE;MACrC,MAAM,IAAIrB,OAAA,CAAAmC,iBAAiB,EAAE;;IAE/B,OAAOV,sBAAA,KAAI,EAAAC,yBAAA,OAAAU,0BAAA,CAAY,CAAAR,IAAA,CAAhB,IAAI,CAAc;EAC3B;EAiEA,EAAApB,sBAAA,OAAA6B,OAAA,IAAA3B,uCAAA,OAAA2B,OAAA,IAAA1B,6BAAA,OAAA0B,OAAA,IAAAX,yBAAA,OAAAY,OAAA,IAAAX,4BAAA,YAAAA,6BAAA;IA5JE,IAAI,IAAI,CAACY,KAAK,EAAE;IAChB3B,sBAAA,KAAI,EAAAF,uCAAA,EAA4B8B,SAAS;EAC3C,CAAC,EAAAN,wBAAA,YAAAA,yBAEwCD,KAA0B;IACjE,IAAI,IAAI,CAACM,KAAK,EAAE;IAEhB,MAAME,QAAQ,GAAGhB,sBAAA,KAAI,EAAAC,yBAAA,OAAAgB,kCAAA,CAAoB,CAAAd,IAAA,CAAxB,IAAI,EAAqBK,KAAK,CAAC;IAChD,IAAI,CAACU,KAAK,CAAC,OAAO,EAAEV,KAAK,CAAC;IAE1B,QAAQA,KAAK,CAACW,IAAI;MAChB,KAAK,4BAA4B;QAAE;UACjC,MAAMC,MAAM,GAAGJ,QAAQ,CAACI,MAAM,CAACZ,KAAK,CAACa,YAAY,CAAC;UAClD,IAAI,CAACD,MAAM,EAAE;YACX,MAAM,IAAI7C,OAAA,CAAA+C,WAAW,CAAC,2BAA2Bd,KAAK,CAACa,YAAY,EAAE,CAAC;;UAExE,IAAID,MAAM,CAACD,IAAI,KAAK,SAAS,EAAE;YAC7B,MAAMI,OAAO,GAAGH,MAAM,CAACG,OAAO,CAACf,KAAK,CAACgB,aAAa,CAAC;YACnD,IAAI,CAACD,OAAO,EAAE;cACZ,MAAM,IAAIhD,OAAA,CAAA+C,WAAW,CAAC,4BAA4Bd,KAAK,CAACgB,aAAa,EAAE,CAAC;;YAE1E,IAAID,OAAO,CAACJ,IAAI,KAAK,aAAa,EAAE;cAClC,MAAM,IAAI5C,OAAA,CAAA+C,WAAW,CAAC,6CAA6CC,OAAO,CAACJ,IAAI,EAAE,CAAC;;YAGpF,IAAI,CAACD,KAAK,CAAC,4BAA4B,EAAE;cACvC,GAAGV,KAAK;cACRiB,QAAQ,EAAEF,OAAO,CAACG;aACnB,CAAC;;UAEJ;;MAEF,KAAK,wCAAwC;QAAE;UAC7C,MAAMN,MAAM,GAAGJ,QAAQ,CAACI,MAAM,CAACZ,KAAK,CAACa,YAAY,CAAC;UAClD,IAAI,CAACD,MAAM,EAAE;YACX,MAAM,IAAI7C,OAAA,CAAA+C,WAAW,CAAC,2BAA2Bd,KAAK,CAACa,YAAY,EAAE,CAAC;;UAExE,IAAID,MAAM,CAACD,IAAI,KAAK,eAAe,EAAE;YACnC,IAAI,CAACD,KAAK,CAAC,wCAAwC,EAAE;cACnD,GAAGV,KAAK;cACRiB,QAAQ,EAAEL,MAAM,CAACO;aAClB,CAAC;;UAEJ;;MAEF;QACE;QACA,IAAI,CAACT,KAAK,CAACV,KAAK,CAACW,IAAI,EAAEX,KAAK,CAAC;QAC7B;;EAEN,CAAC,EAAAG,0BAAA,YAAAA,2BAAA;IAGC,IAAI,IAAI,CAACG,KAAK,EAAE;MACd,MAAM,IAAIvC,OAAA,CAAA+C,WAAW,CAAC,yCAAyC,CAAC;;IAElE,MAAMG,QAAQ,GAAGzB,sBAAA,KAAI,EAAAf,uCAAA,MAAyB;IAC9C,IAAI,CAACwC,QAAQ,EAAE;MACb,MAAM,IAAIlD,OAAA,CAAA+C,WAAW,CAAC,0CAA0C,CAAC;;IAEnEnC,sBAAA,KAAI,EAAAF,uCAAA,EAA4B8B,SAAS;IACzC,MAAMa,cAAc,GAAGC,gBAAgB,CAAUJ,QAAQ,EAAEzB,sBAAA,KAAI,EAAAjB,sBAAA,MAAQ,CAAC;IACxEI,sBAAA,KAAI,EAAAD,6BAAA,EAAkB0C,cAAc;IAEpC,OAAOA,cAAc;EACvB,CAAC,EAAAX,kCAAA,YAAAA,mCA4BmBT,KAA0B;IAC5C,IAAIiB,QAAQ,GAAGzB,sBAAA,KAAI,EAAAf,uCAAA,MAAyB;IAC5C,IAAI,CAACwC,QAAQ,EAAE;MACb,IAAIjB,KAAK,CAACW,IAAI,KAAK,kBAAkB,EAAE;QACrC,MAAM,IAAI5C,OAAA,CAAA+C,WAAW,CACnB,6EAA6Ed,KAAK,CAACW,IAAI,EAAE,CAC1F;;MAEHM,QAAQ,GAAGtC,sBAAA,KAAI,EAAAF,uCAAA,EAA4BuB,KAAK,CAACQ,QAAQ;MACzD,OAAOS,QAAQ;;IAGjB,QAAQjB,KAAK,CAACW,IAAI;MAChB,KAAK,4BAA4B;QAAE;UACjCM,QAAQ,CAACL,MAAM,CAACU,IAAI,CAACtB,KAAK,CAACuB,IAAI,CAAC;UAChC;;MAEF,KAAK,6BAA6B;QAAE;UAClC,MAAMX,MAAM,GAAGK,QAAQ,CAACL,MAAM,CAACZ,KAAK,CAACa,YAAY,CAAC;UAClD,IAAI,CAACD,MAAM,EAAE;YACX,MAAM,IAAI7C,OAAA,CAAA+C,WAAW,CAAC,2BAA2Bd,KAAK,CAACa,YAAY,EAAE,CAAC;;UAExE,IAAID,MAAM,CAACD,IAAI,KAAK,SAAS,EAAE;YAC7BC,MAAM,CAACG,OAAO,CAACO,IAAI,CAACtB,KAAK,CAACwB,IAAI,CAAC;;UAEjC;;MAEF,KAAK,4BAA4B;QAAE;UACjC,MAAMZ,MAAM,GAAGK,QAAQ,CAACL,MAAM,CAACZ,KAAK,CAACa,YAAY,CAAC;UAClD,IAAI,CAACD,MAAM,EAAE;YACX,MAAM,IAAI7C,OAAA,CAAA+C,WAAW,CAAC,2BAA2Bd,KAAK,CAACa,YAAY,EAAE,CAAC;;UAExE,IAAID,MAAM,CAACD,IAAI,KAAK,SAAS,EAAE;YAC7B,MAAMI,OAAO,GAAGH,MAAM,CAACG,OAAO,CAACf,KAAK,CAACgB,aAAa,CAAC;YACnD,IAAI,CAACD,OAAO,EAAE;cACZ,MAAM,IAAIhD,OAAA,CAAA+C,WAAW,CAAC,4BAA4Bd,KAAK,CAACgB,aAAa,EAAE,CAAC;;YAE1E,IAAID,OAAO,CAACJ,IAAI,KAAK,aAAa,EAAE;cAClC,MAAM,IAAI5C,OAAA,CAAA+C,WAAW,CAAC,6CAA6CC,OAAO,CAACJ,IAAI,EAAE,CAAC;;YAEpFI,OAAO,CAACG,IAAI,IAAIlB,KAAK,CAACyB,KAAK;;UAE7B;;MAEF,KAAK,wCAAwC;QAAE;UAC7C,MAAMb,MAAM,GAAGK,QAAQ,CAACL,MAAM,CAACZ,KAAK,CAACa,YAAY,CAAC;UAClD,IAAI,CAACD,MAAM,EAAE;YACX,MAAM,IAAI7C,OAAA,CAAA+C,WAAW,CAAC,2BAA2Bd,KAAK,CAACa,YAAY,EAAE,CAAC;;UAExE,IAAID,MAAM,CAACD,IAAI,KAAK,eAAe,EAAE;YACnCC,MAAM,CAACO,SAAS,IAAInB,KAAK,CAACyB,KAAK;;UAEjC;;MAEF,KAAK,oBAAoB;QAAE;UACzB9C,sBAAA,KAAI,EAAAF,uCAAA,EAA4BuB,KAAK,CAACQ,QAAQ;UAC9C;;;IAIJ,OAAOS,QAAQ;EACjB,CAAC,EAEAS,MAAM,CAACC,aAAa,KAAC;IACpB,MAAMC,SAAS,GAA0B,EAAE;IAC3C,MAAMC,SAAS,GAGT,EAAE;IACR,IAAIC,IAAI,GAAG,KAAK;IAEhB,IAAI,CAACC,EAAE,CAAC,OAAO,EAAG/B,KAAK,IAAI;MACzB,MAAMgC,MAAM,GAAGH,SAAS,CAACI,KAAK,EAAE;MAChC,IAAID,MAAM,EAAE;QACVA,MAAM,CAACE,OAAO,CAAClC,KAAK,CAAC;OACtB,MAAM;QACL4B,SAAS,CAACN,IAAI,CAACtB,KAAK,CAAC;;IAEzB,CAAC,CAAC;IAEF,IAAI,CAAC+B,EAAE,CAAC,KAAK,EAAE,MAAK;MAClBD,IAAI,GAAG,IAAI;MACX,KAAK,MAAME,MAAM,IAAIH,SAAS,EAAE;QAC9BG,MAAM,CAACE,OAAO,CAAC3B,SAAS,CAAC;;MAE3BsB,SAAS,CAACM,MAAM,GAAG,CAAC;IACtB,CAAC,CAAC;IAEF,IAAI,CAACJ,EAAE,CAAC,OAAO,EAAGK,GAAG,IAAI;MACvBN,IAAI,GAAG,IAAI;MACX,KAAK,MAAME,MAAM,IAAIH,SAAS,EAAE;QAC9BG,MAAM,CAACK,MAAM,CAACD,GAAG,CAAC;;MAEpBP,SAAS,CAACM,MAAM,GAAG,CAAC;IACtB,CAAC,CAAC;IAEF,IAAI,CAACJ,EAAE,CAAC,OAAO,EAAGK,GAAG,IAAI;MACvBN,IAAI,GAAG,IAAI;MACX,KAAK,MAAME,MAAM,IAAIH,SAAS,EAAE;QAC9BG,MAAM,CAACK,MAAM,CAACD,GAAG,CAAC;;MAEpBP,SAAS,CAACM,MAAM,GAAG,CAAC;IACtB,CAAC,CAAC;IAEF,OAAO;MACLG,IAAI,EAAE,MAAAA,CAAA,KAAyD;QAC7D,IAAI,CAACV,SAAS,CAACO,MAAM,EAAE;UACrB,IAAIL,IAAI,EAAE;YACR,OAAO;cAAES,KAAK,EAAEhC,SAAS;cAAEuB,IAAI,EAAE;YAAI,CAAE;;UAEzC,OAAO,IAAIU,OAAO,CAAkC,CAACN,OAAO,EAAEG,MAAM,KAClER,SAAS,CAACP,IAAI,CAAC;YAAEY,OAAO;YAAEG;UAAM,CAAE,CAAC,CACpC,CAACI,IAAI,CAAEzC,KAAK,IAAMA,KAAK,GAAG;YAAEuC,KAAK,EAAEvC,KAAK;YAAE8B,IAAI,EAAE;UAAK,CAAE,GAAG;YAAES,KAAK,EAAEhC,SAAS;YAAEuB,IAAI,EAAE;UAAI,CAAG,CAAC;;QAE/F,MAAM9B,KAAK,GAAG4B,SAAS,CAACK,KAAK,EAAG;QAChC,OAAO;UAAEM,KAAK,EAAEvC,KAAK;UAAE8B,IAAI,EAAE;QAAK,CAAE;MACtC,CAAC;MACDY,MAAM,EAAE,MAAAA,CAAA,KAAW;QACjB,IAAI,CAACpD,KAAK,EAAE;QACZ,OAAO;UAAEiD,KAAK,EAAEhC,SAAS;UAAEuB,IAAI,EAAE;QAAI,CAAE;MACzC;KACD;EACH;EAEA;;;;EAIA,MAAMa,aAAaA,CAAA;IACjB,MAAM,IAAI,CAACb,IAAI,EAAE;IACjB,MAAMtB,QAAQ,GAAGhB,sBAAA,KAAI,EAAAd,6BAAA,MAAe;IACpC,IAAI,CAAC8B,QAAQ,EAAE,MAAM,IAAIzC,OAAA,CAAA+C,WAAW,CAAC,iDAAiD,CAAC;IACvF,OAAON,QAAQ;EACjB;;AA/PFoC,OAAA,CAAAzE,cAAA,GAAAA,cAAA;AAkQA,SAASkD,gBAAgBA,CACvBJ,QAAkB,EAClB3C,MAAsC;EAEtC,OAAO,IAAAJ,iBAAA,CAAA2E,kBAAkB,EAAC5B,QAAQ,EAAE3C,MAAM,CAAC;AAC7C","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}