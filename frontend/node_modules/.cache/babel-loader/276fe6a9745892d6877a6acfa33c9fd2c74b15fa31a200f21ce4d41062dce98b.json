{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _AbstractPage_client;\nimport { VERSION } from \"./version.mjs\";\nimport { Stream } from \"./streaming.mjs\";\nimport { OpenAIError, APIError, APIConnectionError, APIConnectionTimeoutError, APIUserAbortError } from \"./error.mjs\";\nimport { kind as shimsKind, getDefaultAgent, fetch } from \"./_shims/index.mjs\";\nimport { isBlobLike, isMultipartBody } from \"./uploads.mjs\";\nexport { maybeMultipartFormRequestOptions, multipartFormRequestOptions, createForm } from \"./uploads.mjs\";\nasync function defaultParseResponse(props) {\n  const {\n    response\n  } = props;\n  if (props.options.stream) {\n    debug('response', response.status, response.url, response.headers, response.body);\n    // Note: there is an invariant here that isn't represented in the type system\n    // that if you set `stream: true` the response type must also be `Stream<T>`\n    if (props.options.__streamClass) {\n      return props.options.__streamClass.fromSSEResponse(response, props.controller);\n    }\n    return Stream.fromSSEResponse(response, props.controller);\n  }\n  // fetch refuses to read the body when the status code is 204.\n  if (response.status === 204) {\n    return null;\n  }\n  if (props.options.__binaryResponse) {\n    return response;\n  }\n  const contentType = response.headers.get('content-type');\n  const mediaType = contentType?.split(';')[0]?.trim();\n  const isJSON = mediaType?.includes('application/json') || mediaType?.endsWith('+json');\n  if (isJSON) {\n    const json = await response.json();\n    debug('response', response.status, response.url, response.headers, json);\n    return _addRequestID(json, response);\n  }\n  const text = await response.text();\n  debug('response', response.status, response.url, response.headers, text);\n  // TODO handle blob, arraybuffer, other content types, etc.\n  return text;\n}\nfunction _addRequestID(value, response) {\n  if (!value || typeof value !== 'object' || Array.isArray(value)) {\n    return value;\n  }\n  return Object.defineProperty(value, '_request_id', {\n    value: response.headers.get('x-request-id'),\n    enumerable: false\n  });\n}\n/**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */\nexport class APIPromise extends Promise {\n  constructor(responsePromise, parseResponse = defaultParseResponse) {\n    super(resolve => {\n      // this is maybe a bit weird but this has to be a no-op to not implicitly\n      // parse the response body; instead .then, .catch, .finally are overridden\n      // to parse the response\n      resolve(null);\n    });\n    this.responsePromise = responsePromise;\n    this.parseResponse = parseResponse;\n  }\n  _thenUnwrap(transform) {\n    return new APIPromise(this.responsePromise, async props => _addRequestID(transform(await this.parseResponse(props), props), props.response));\n  }\n  /**\n   * Gets the raw `Response` instance instead of parsing the response\n   * data.\n   *\n   * If you want to parse the response body but still get the `Response`\n   * instance, you can use {@link withResponse()}.\n   *\n   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?\n   * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n   * or add one of these imports before your first `import â€¦ from 'openai'`:\n   * - `import 'openai/shims/node'` (if you're running on Node)\n   * - `import 'openai/shims/web'` (otherwise)\n   */\n  asResponse() {\n    return this.responsePromise.then(p => p.response);\n  }\n  /**\n   * Gets the parsed response data, the raw `Response` instance and the ID of the request,\n   * returned via the X-Request-ID header which is useful for debugging requests and reporting\n   * issues to OpenAI.\n   *\n   * If you just want to get the raw `Response` instance without parsing it,\n   * you can use {@link asResponse()}.\n   *\n   *\n   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?\n   * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n   * or add one of these imports before your first `import â€¦ from 'openai'`:\n   * - `import 'openai/shims/node'` (if you're running on Node)\n   * - `import 'openai/shims/web'` (otherwise)\n   */\n  async withResponse() {\n    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\n    return {\n      data,\n      response,\n      request_id: response.headers.get('x-request-id')\n    };\n  }\n  parse() {\n    if (!this.parsedPromise) {\n      this.parsedPromise = this.responsePromise.then(this.parseResponse);\n    }\n    return this.parsedPromise;\n  }\n  then(onfulfilled, onrejected) {\n    return this.parse().then(onfulfilled, onrejected);\n  }\n  catch(onrejected) {\n    return this.parse().catch(onrejected);\n  }\n  finally(onfinally) {\n    return this.parse().finally(onfinally);\n  }\n}\nexport class APIClient {\n  constructor({\n    baseURL,\n    maxRetries = 2,\n    timeout = 600000,\n    // 10 minutes\n    httpAgent,\n    fetch: overriddenFetch\n  }) {\n    this.baseURL = baseURL;\n    this.maxRetries = validatePositiveInteger('maxRetries', maxRetries);\n    this.timeout = validatePositiveInteger('timeout', timeout);\n    this.httpAgent = httpAgent;\n    this.fetch = overriddenFetch ?? fetch;\n  }\n  authHeaders(opts) {\n    return {};\n  }\n  /**\n   * Override this to add your own default headers, for example:\n   *\n   *  {\n   *    ...super.defaultHeaders(),\n   *    Authorization: 'Bearer 123',\n   *  }\n   */\n  defaultHeaders(opts) {\n    return {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n      'User-Agent': this.getUserAgent(),\n      ...getPlatformHeaders(),\n      ...this.authHeaders(opts)\n    };\n  }\n  /**\n   * Override this to add your own headers validation:\n   */\n  validateHeaders(headers, customHeaders) {}\n  defaultIdempotencyKey() {\n    return `stainless-node-retry-${uuid4()}`;\n  }\n  get(path, opts) {\n    return this.methodRequest('get', path, opts);\n  }\n  post(path, opts) {\n    return this.methodRequest('post', path, opts);\n  }\n  patch(path, opts) {\n    return this.methodRequest('patch', path, opts);\n  }\n  put(path, opts) {\n    return this.methodRequest('put', path, opts);\n  }\n  delete(path, opts) {\n    return this.methodRequest('delete', path, opts);\n  }\n  methodRequest(method, path, opts) {\n    return this.request(Promise.resolve(opts).then(async opts => {\n      const body = opts && isBlobLike(opts?.body) ? new DataView(await opts.body.arrayBuffer()) : opts?.body instanceof DataView ? opts.body : opts?.body instanceof ArrayBuffer ? new DataView(opts.body) : opts && ArrayBuffer.isView(opts?.body) ? new DataView(opts.body.buffer) : opts?.body;\n      return {\n        method,\n        path,\n        ...opts,\n        body\n      };\n    }));\n  }\n  getAPIList(path, Page, opts) {\n    return this.requestAPIList(Page, {\n      method: 'get',\n      path,\n      ...opts\n    });\n  }\n  calculateContentLength(body) {\n    if (typeof body === 'string') {\n      if (typeof Buffer !== 'undefined') {\n        return Buffer.byteLength(body, 'utf8').toString();\n      }\n      if (typeof TextEncoder !== 'undefined') {\n        const encoder = new TextEncoder();\n        const encoded = encoder.encode(body);\n        return encoded.length.toString();\n      }\n    } else if (ArrayBuffer.isView(body)) {\n      return body.byteLength.toString();\n    }\n    return null;\n  }\n  buildRequest(options, {\n    retryCount = 0\n  } = {}) {\n    options = {\n      ...options\n    };\n    const {\n      method,\n      path,\n      query,\n      headers = {}\n    } = options;\n    const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === 'string' ? options.body : isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;\n    const contentLength = this.calculateContentLength(body);\n    const url = this.buildURL(path, query);\n    if ('timeout' in options) validatePositiveInteger('timeout', options.timeout);\n    options.timeout = options.timeout ?? this.timeout;\n    const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);\n    const minAgentTimeout = options.timeout + 1000;\n    if (typeof httpAgent?.options?.timeout === 'number' && minAgentTimeout > (httpAgent.options.timeout ?? 0)) {\n      // Allow any given request to bump our agent active socket timeout.\n      // This may seem strange, but leaking active sockets should be rare and not particularly problematic,\n      // and without mutating agent we would need to create more of them.\n      // This tradeoff optimizes for performance.\n      httpAgent.options.timeout = minAgentTimeout;\n    }\n    if (this.idempotencyHeader && method !== 'get') {\n      if (!options.idempotencyKey) options.idempotencyKey = this.defaultIdempotencyKey();\n      headers[this.idempotencyHeader] = options.idempotencyKey;\n    }\n    const reqHeaders = this.buildHeaders({\n      options,\n      headers,\n      contentLength,\n      retryCount\n    });\n    const req = {\n      method,\n      ...(body && {\n        body: body\n      }),\n      headers: reqHeaders,\n      ...(httpAgent && {\n        agent: httpAgent\n      }),\n      // @ts-ignore node-fetch uses a custom AbortSignal type that is\n      // not compatible with standard web types\n      signal: options.signal ?? null\n    };\n    return {\n      req,\n      url,\n      timeout: options.timeout\n    };\n  }\n  buildHeaders({\n    options,\n    headers,\n    contentLength,\n    retryCount\n  }) {\n    const reqHeaders = {};\n    if (contentLength) {\n      reqHeaders['content-length'] = contentLength;\n    }\n    const defaultHeaders = this.defaultHeaders(options);\n    applyHeadersMut(reqHeaders, defaultHeaders);\n    applyHeadersMut(reqHeaders, headers);\n    // let builtin fetch set the Content-Type for multipart bodies\n    if (isMultipartBody(options.body) && shimsKind !== 'node') {\n      delete reqHeaders['content-type'];\n    }\n    // Don't set theses headers if they were already set or removed through default headers or by the caller.\n    // We check `defaultHeaders` and `headers`, which can contain nulls, instead of `reqHeaders` to account\n    // for the removal case.\n    if (getHeader(defaultHeaders, 'x-stainless-retry-count') === undefined && getHeader(headers, 'x-stainless-retry-count') === undefined) {\n      reqHeaders['x-stainless-retry-count'] = String(retryCount);\n    }\n    if (getHeader(defaultHeaders, 'x-stainless-timeout') === undefined && getHeader(headers, 'x-stainless-timeout') === undefined && options.timeout) {\n      reqHeaders['x-stainless-timeout'] = String(options.timeout);\n    }\n    this.validateHeaders(reqHeaders, headers);\n    return reqHeaders;\n  }\n  /**\n   * Used as a callback for mutating the given `FinalRequestOptions` object.\n   */\n  async prepareOptions(options) {}\n  /**\n   * Used as a callback for mutating the given `RequestInit` object.\n   *\n   * This is useful for cases where you want to add certain headers based off of\n   * the request properties, e.g. `method` or `url`.\n   */\n  async prepareRequest(request, {\n    url,\n    options\n  }) {}\n  parseHeaders(headers) {\n    return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map(header => [...header])) : {\n      ...headers\n    };\n  }\n  makeStatusError(status, error, message, headers) {\n    return APIError.generate(status, error, message, headers);\n  }\n  request(options, remainingRetries = null) {\n    return new APIPromise(this.makeRequest(options, remainingRetries));\n  }\n  async makeRequest(optionsInput, retriesRemaining) {\n    const options = await optionsInput;\n    const maxRetries = options.maxRetries ?? this.maxRetries;\n    if (retriesRemaining == null) {\n      retriesRemaining = maxRetries;\n    }\n    await this.prepareOptions(options);\n    const {\n      req,\n      url,\n      timeout\n    } = this.buildRequest(options, {\n      retryCount: maxRetries - retriesRemaining\n    });\n    await this.prepareRequest(req, {\n      url,\n      options\n    });\n    debug('request', url, options, req.headers);\n    if (options.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    const controller = new AbortController();\n    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);\n    if (response instanceof Error) {\n      if (options.signal?.aborted) {\n        throw new APIUserAbortError();\n      }\n      if (retriesRemaining) {\n        return this.retryRequest(options, retriesRemaining);\n      }\n      if (response.name === 'AbortError') {\n        throw new APIConnectionTimeoutError();\n      }\n      throw new APIConnectionError({\n        cause: response\n      });\n    }\n    const responseHeaders = createResponseHeaders(response.headers);\n    if (!response.ok) {\n      if (retriesRemaining && this.shouldRetry(response)) {\n        const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;\n        debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders);\n        return this.retryRequest(options, retriesRemaining, responseHeaders);\n      }\n      const errText = await response.text().catch(e => castToError(e).message);\n      const errJSON = safeJSON(errText);\n      const errMessage = errJSON ? undefined : errText;\n      const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;\n      debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);\n      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);\n      throw err;\n    }\n    return {\n      response,\n      options,\n      controller\n    };\n  }\n  requestAPIList(Page, options) {\n    const request = this.makeRequest(options, null);\n    return new PagePromise(this, request, Page);\n  }\n  buildURL(path, query) {\n    const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));\n    const defaultQuery = this.defaultQuery();\n    if (!isEmptyObj(defaultQuery)) {\n      query = {\n        ...defaultQuery,\n        ...query\n      };\n    }\n    if (typeof query === 'object' && query && !Array.isArray(query)) {\n      url.search = this.stringifyQuery(query);\n    }\n    return url.toString();\n  }\n  stringifyQuery(query) {\n    return Object.entries(query).filter(([_, value]) => typeof value !== 'undefined').map(([key, value]) => {\n      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n      }\n      if (value === null) {\n        return `${encodeURIComponent(key)}=`;\n      }\n      throw new OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);\n    }).join('&');\n  }\n  async fetchWithTimeout(url, init, ms, controller) {\n    const {\n      signal,\n      ...options\n    } = init || {};\n    if (signal) signal.addEventListener('abort', () => controller.abort());\n    const timeout = setTimeout(() => controller.abort(), ms);\n    const fetchOptions = {\n      signal: controller.signal,\n      ...options\n    };\n    if (fetchOptions.method) {\n      // Custom methods like 'patch' need to be uppercased\n      // See https://github.com/nodejs/undici/issues/2294\n      fetchOptions.method = fetchOptions.method.toUpperCase();\n    }\n    return (\n      // use undefined this binding; fetch errors if bound to something else in browser/cloudflare\n      this.fetch.call(undefined, url, fetchOptions).finally(() => {\n        clearTimeout(timeout);\n      })\n    );\n  }\n  shouldRetry(response) {\n    // Note this is not a standard header.\n    const shouldRetryHeader = response.headers.get('x-should-retry');\n    // If the server explicitly says whether or not to retry, obey.\n    if (shouldRetryHeader === 'true') return true;\n    if (shouldRetryHeader === 'false') return false;\n    // Retry on request timeouts.\n    if (response.status === 408) return true;\n    // Retry on lock timeouts.\n    if (response.status === 409) return true;\n    // Retry on rate limits.\n    if (response.status === 429) return true;\n    // Retry internal errors.\n    if (response.status >= 500) return true;\n    return false;\n  }\n  async retryRequest(options, retriesRemaining, responseHeaders) {\n    let timeoutMillis;\n    // Note the `retry-after-ms` header may not be standard, but is a good idea and we'd like proactive support for it.\n    const retryAfterMillisHeader = responseHeaders?.['retry-after-ms'];\n    if (retryAfterMillisHeader) {\n      const timeoutMs = parseFloat(retryAfterMillisHeader);\n      if (!Number.isNaN(timeoutMs)) {\n        timeoutMillis = timeoutMs;\n      }\n    }\n    // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\n    const retryAfterHeader = responseHeaders?.['retry-after'];\n    if (retryAfterHeader && !timeoutMillis) {\n      const timeoutSeconds = parseFloat(retryAfterHeader);\n      if (!Number.isNaN(timeoutSeconds)) {\n        timeoutMillis = timeoutSeconds * 1000;\n      } else {\n        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();\n      }\n    }\n    // If the API asks us to wait a certain amount of time (and it's a reasonable amount),\n    // just do what it says, but otherwise calculate a default\n    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {\n      const maxRetries = options.maxRetries ?? this.maxRetries;\n      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);\n    }\n    await sleep(timeoutMillis);\n    return this.makeRequest(options, retriesRemaining - 1);\n  }\n  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {\n    const initialRetryDelay = 0.5;\n    const maxRetryDelay = 8.0;\n    const numRetries = maxRetries - retriesRemaining;\n    // Apply exponential backoff, but not more than the max.\n    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);\n    // Apply some jitter, take up to at most 25 percent of the retry time.\n    const jitter = 1 - Math.random() * 0.25;\n    return sleepSeconds * jitter * 1000;\n  }\n  getUserAgent() {\n    return `${this.constructor.name}/JS ${VERSION}`;\n  }\n}\nexport class AbstractPage {\n  constructor(client, response, body, options) {\n    _AbstractPage_client.set(this, void 0);\n    __classPrivateFieldSet(this, _AbstractPage_client, client, \"f\");\n    this.options = options;\n    this.response = response;\n    this.body = body;\n  }\n  hasNextPage() {\n    const items = this.getPaginatedItems();\n    if (!items.length) return false;\n    return this.nextPageInfo() != null;\n  }\n  async getNextPage() {\n    const nextInfo = this.nextPageInfo();\n    if (!nextInfo) {\n      throw new OpenAIError('No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.');\n    }\n    const nextOptions = {\n      ...this.options\n    };\n    if ('params' in nextInfo && typeof nextOptions.query === 'object') {\n      nextOptions.query = {\n        ...nextOptions.query,\n        ...nextInfo.params\n      };\n    } else if ('url' in nextInfo) {\n      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];\n      for (const [key, value] of params) {\n        nextInfo.url.searchParams.set(key, value);\n      }\n      nextOptions.query = undefined;\n      nextOptions.path = nextInfo.url.toString();\n    }\n    return await __classPrivateFieldGet(this, _AbstractPage_client, \"f\").requestAPIList(this.constructor, nextOptions);\n  }\n  async *iterPages() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let page = this;\n    yield page;\n    while (page.hasNextPage()) {\n      page = await page.getNextPage();\n      yield page;\n    }\n  }\n  async *[(_AbstractPage_client = new WeakMap(), Symbol.asyncIterator)]() {\n    for await (const page of this.iterPages()) {\n      for (const item of page.getPaginatedItems()) {\n        yield item;\n      }\n    }\n  }\n}\n/**\n * This subclass of Promise will resolve to an instantiated Page once the request completes.\n *\n * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:\n *\n *    for await (const item of client.items.list()) {\n *      console.log(item)\n *    }\n */\nexport class PagePromise extends APIPromise {\n  constructor(client, request, Page) {\n    super(request, async props => new Page(client, props.response, await defaultParseResponse(props), props.options));\n  }\n  /**\n   * Allow auto-paginating iteration on an unawaited list call, eg:\n   *\n   *    for await (const item of client.items.list()) {\n   *      console.log(item)\n   *    }\n   */\n  async *[Symbol.asyncIterator]() {\n    const page = await this;\n    for await (const item of page) {\n      yield item;\n    }\n  }\n}\nexport const createResponseHeaders = headers => {\n  return new Proxy(Object.fromEntries(\n  // @ts-ignore\n  headers.entries()), {\n    get(target, name) {\n      const key = name.toString();\n      return target[key.toLowerCase()] || target[key];\n    }\n  });\n};\n// This is required so that we can determine if a given object matches the RequestOptions\n// type at runtime. While this requires duplication, it is enforced by the TypeScript\n// compiler such that any missing / extraneous keys will cause an error.\nconst requestOptionsKeys = {\n  method: true,\n  path: true,\n  query: true,\n  body: true,\n  headers: true,\n  maxRetries: true,\n  stream: true,\n  timeout: true,\n  httpAgent: true,\n  signal: true,\n  idempotencyKey: true,\n  __metadata: true,\n  __binaryRequest: true,\n  __binaryResponse: true,\n  __streamClass: true\n};\nexport const isRequestOptions = obj => {\n  return typeof obj === 'object' && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every(k => hasOwn(requestOptionsKeys, k));\n};\nconst getPlatformProperties = () => {\n  if (typeof Deno !== 'undefined' && Deno.build != null) {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': normalizePlatform(Deno.build.os),\n      'X-Stainless-Arch': normalizeArch(Deno.build.arch),\n      'X-Stainless-Runtime': 'deno',\n      'X-Stainless-Runtime-Version': typeof Deno.version === 'string' ? Deno.version : Deno.version?.deno ?? 'unknown'\n    };\n  }\n  if (typeof EdgeRuntime !== 'undefined') {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': 'Unknown',\n      'X-Stainless-Arch': `other:${EdgeRuntime}`,\n      'X-Stainless-Runtime': 'edge',\n      'X-Stainless-Runtime-Version': process.version\n    };\n  }\n  // Check if Node.js\n  if (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]') {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': normalizePlatform(process.platform),\n      'X-Stainless-Arch': normalizeArch(process.arch),\n      'X-Stainless-Runtime': 'node',\n      'X-Stainless-Runtime-Version': process.version\n    };\n  }\n  const browserInfo = getBrowserInfo();\n  if (browserInfo) {\n    return {\n      'X-Stainless-Lang': 'js',\n      'X-Stainless-Package-Version': VERSION,\n      'X-Stainless-OS': 'Unknown',\n      'X-Stainless-Arch': 'unknown',\n      'X-Stainless-Runtime': `browser:${browserInfo.browser}`,\n      'X-Stainless-Runtime-Version': browserInfo.version\n    };\n  }\n  // TODO add support for Cloudflare workers, etc.\n  return {\n    'X-Stainless-Lang': 'js',\n    'X-Stainless-Package-Version': VERSION,\n    'X-Stainless-OS': 'Unknown',\n    'X-Stainless-Arch': 'unknown',\n    'X-Stainless-Runtime': 'unknown',\n    'X-Stainless-Runtime-Version': 'unknown'\n  };\n};\n// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts\nfunction getBrowserInfo() {\n  if (typeof navigator === 'undefined' || !navigator) {\n    return null;\n  }\n  // NOTE: The order matters here!\n  const browserPatterns = [{\n    key: 'edge',\n    pattern: /Edge(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n  }, {\n    key: 'ie',\n    pattern: /MSIE(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n  }, {\n    key: 'ie',\n    pattern: /Trident(?:.*rv\\:(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n  }, {\n    key: 'chrome',\n    pattern: /Chrome(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n  }, {\n    key: 'firefox',\n    pattern: /Firefox(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/\n  }, {\n    key: 'safari',\n    pattern: /(?:Version\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?(?:\\W+Mobile\\S*)?\\W+Safari/\n  }];\n  // Find the FIRST matching browser\n  for (const {\n    key,\n    pattern\n  } of browserPatterns) {\n    const match = pattern.exec(navigator.userAgent);\n    if (match) {\n      const major = match[1] || 0;\n      const minor = match[2] || 0;\n      const patch = match[3] || 0;\n      return {\n        browser: key,\n        version: `${major}.${minor}.${patch}`\n      };\n    }\n  }\n  return null;\n}\nconst normalizeArch = arch => {\n  // Node docs:\n  // - https://nodejs.org/api/process.html#processarch\n  // Deno docs:\n  // - https://doc.deno.land/deno/stable/~/Deno.build\n  if (arch === 'x32') return 'x32';\n  if (arch === 'x86_64' || arch === 'x64') return 'x64';\n  if (arch === 'arm') return 'arm';\n  if (arch === 'aarch64' || arch === 'arm64') return 'arm64';\n  if (arch) return `other:${arch}`;\n  return 'unknown';\n};\nconst normalizePlatform = platform => {\n  // Node platforms:\n  // - https://nodejs.org/api/process.html#processplatform\n  // Deno platforms:\n  // - https://doc.deno.land/deno/stable/~/Deno.build\n  // - https://github.com/denoland/deno/issues/14799\n  platform = platform.toLowerCase();\n  // NOTE: this iOS check is untested and may not work\n  // Node does not work natively on IOS, there is a fork at\n  // https://github.com/nodejs-mobile/nodejs-mobile\n  // however it is unknown at the time of writing how to detect if it is running\n  if (platform.includes('ios')) return 'iOS';\n  if (platform === 'android') return 'Android';\n  if (platform === 'darwin') return 'MacOS';\n  if (platform === 'win32') return 'Windows';\n  if (platform === 'freebsd') return 'FreeBSD';\n  if (platform === 'openbsd') return 'OpenBSD';\n  if (platform === 'linux') return 'Linux';\n  if (platform) return `Other:${platform}`;\n  return 'Unknown';\n};\nlet _platformHeaders;\nconst getPlatformHeaders = () => {\n  return _platformHeaders ?? (_platformHeaders = getPlatformProperties());\n};\nexport const safeJSON = text => {\n  try {\n    return JSON.parse(text);\n  } catch (err) {\n    return undefined;\n  }\n};\n// https://url.spec.whatwg.org/#url-scheme-string\nconst startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;\nconst isAbsoluteURL = url => {\n  return startsWithSchemeRegexp.test(url);\n};\nexport const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\nconst validatePositiveInteger = (name, n) => {\n  if (typeof n !== 'number' || !Number.isInteger(n)) {\n    throw new OpenAIError(`${name} must be an integer`);\n  }\n  if (n < 0) {\n    throw new OpenAIError(`${name} must be a positive integer`);\n  }\n  return n;\n};\nexport const castToError = err => {\n  if (err instanceof Error) return err;\n  if (typeof err === 'object' && err !== null) {\n    try {\n      return new Error(JSON.stringify(err));\n    } catch {}\n  }\n  return new Error(err);\n};\nexport const ensurePresent = value => {\n  if (value == null) throw new OpenAIError(`Expected a value to be given but received ${value} instead.`);\n  return value;\n};\n/**\n * Read an environment variable.\n *\n * Trims beginning and trailing whitespace.\n *\n * Will return undefined if the environment variable doesn't exist or cannot be accessed.\n */\nexport const readEnv = env => {\n  if (typeof process !== 'undefined') {\n    return process.env?.[env]?.trim() ?? undefined;\n  }\n  if (typeof Deno !== 'undefined') {\n    return Deno.env?.get?.(env)?.trim();\n  }\n  return undefined;\n};\nexport const coerceInteger = value => {\n  if (typeof value === 'number') return Math.round(value);\n  if (typeof value === 'string') return parseInt(value, 10);\n  throw new OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nexport const coerceFloat = value => {\n  if (typeof value === 'number') return value;\n  if (typeof value === 'string') return parseFloat(value);\n  throw new OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nexport const coerceBoolean = value => {\n  if (typeof value === 'boolean') return value;\n  if (typeof value === 'string') return value === 'true';\n  return Boolean(value);\n};\nexport const maybeCoerceInteger = value => {\n  if (value === undefined) {\n    return undefined;\n  }\n  return coerceInteger(value);\n};\nexport const maybeCoerceFloat = value => {\n  if (value === undefined) {\n    return undefined;\n  }\n  return coerceFloat(value);\n};\nexport const maybeCoerceBoolean = value => {\n  if (value === undefined) {\n    return undefined;\n  }\n  return coerceBoolean(value);\n};\n// https://stackoverflow.com/a/34491287\nexport function isEmptyObj(obj) {\n  if (!obj) return true;\n  for (const _k in obj) return false;\n  return true;\n}\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\nexport function hasOwn(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n/**\n * Copies headers from \"newHeaders\" onto \"targetHeaders\",\n * using lower-case for all properties,\n * ignoring any keys with undefined values,\n * and deleting any keys with null values.\n */\nfunction applyHeadersMut(targetHeaders, newHeaders) {\n  for (const k in newHeaders) {\n    if (!hasOwn(newHeaders, k)) continue;\n    const lowerKey = k.toLowerCase();\n    if (!lowerKey) continue;\n    const val = newHeaders[k];\n    if (val === null) {\n      delete targetHeaders[lowerKey];\n    } else if (val !== undefined) {\n      targetHeaders[lowerKey] = val;\n    }\n  }\n}\nconst SENSITIVE_HEADERS = new Set(['authorization', 'api-key']);\nexport function debug(action, ...args) {\n  if (typeof process !== 'undefined' && process?.env?.['DEBUG'] === 'true') {\n    const modifiedArgs = args.map(arg => {\n      if (!arg) {\n        return arg;\n      }\n      // Check for sensitive headers in request body 'headers' object\n      if (arg['headers']) {\n        // clone so we don't mutate\n        const modifiedArg = {\n          ...arg,\n          headers: {\n            ...arg['headers']\n          }\n        };\n        for (const header in arg['headers']) {\n          if (SENSITIVE_HEADERS.has(header.toLowerCase())) {\n            modifiedArg['headers'][header] = 'REDACTED';\n          }\n        }\n        return modifiedArg;\n      }\n      let modifiedArg = null;\n      // Check for sensitive headers in headers object\n      for (const header in arg) {\n        if (SENSITIVE_HEADERS.has(header.toLowerCase())) {\n          // avoid making a copy until we need to\n          modifiedArg ?? (modifiedArg = {\n            ...arg\n          });\n          modifiedArg[header] = 'REDACTED';\n        }\n      }\n      return modifiedArg ?? arg;\n    });\n    console.log(`OpenAI:DEBUG:${action}`, ...modifiedArgs);\n  }\n}\n/**\n * https://stackoverflow.com/a/2117523\n */\nconst uuid4 = () => {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n};\nexport const isRunningInBrowser = () => {\n  return (\n    // @ts-ignore\n    typeof window !== 'undefined' &&\n    // @ts-ignore\n    typeof window.document !== 'undefined' &&\n    // @ts-ignore\n    typeof navigator !== 'undefined'\n  );\n};\nexport const isHeadersProtocol = headers => {\n  return typeof headers?.get === 'function';\n};\nexport const getRequiredHeader = (headers, header) => {\n  const foundHeader = getHeader(headers, header);\n  if (foundHeader === undefined) {\n    throw new Error(`Could not find ${header} header`);\n  }\n  return foundHeader;\n};\nexport const getHeader = (headers, header) => {\n  const lowerCasedHeader = header.toLowerCase();\n  if (isHeadersProtocol(headers)) {\n    // to deal with the case where the header looks like Stainless-Event-Id\n    const intercapsHeader = header[0]?.toUpperCase() + header.substring(1).replace(/([^\\w])(\\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());\n    for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {\n      const value = headers.get(key);\n      if (value) {\n        return value;\n      }\n    }\n  }\n  for (const [key, value] of Object.entries(headers)) {\n    if (key.toLowerCase() === lowerCasedHeader) {\n      if (Array.isArray(value)) {\n        if (value.length <= 1) return value[0];\n        console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);\n        return value[0];\n      }\n      return value;\n    }\n  }\n  return undefined;\n};\n/**\n * Encodes a string to Base64 format.\n */\nexport const toBase64 = str => {\n  if (!str) return '';\n  if (typeof Buffer !== 'undefined') {\n    return Buffer.from(str).toString('base64');\n  }\n  if (typeof btoa !== 'undefined') {\n    return btoa(str);\n  }\n  throw new OpenAIError('Cannot generate b64 string; Expected `Buffer` or `btoa` to be defined');\n};\nexport function isObj(obj) {\n  return obj != null && typeof obj === 'object' && !Array.isArray(obj);\n}","map":{"version":3,"names":["__classPrivateFieldSet","receiver","state","value","kind","f","TypeError","has","call","set","__classPrivateFieldGet","get","_AbstractPage_client","VERSION","Stream","OpenAIError","APIError","APIConnectionError","APIConnectionTimeoutError","APIUserAbortError","shimsKind","getDefaultAgent","fetch","isBlobLike","isMultipartBody","maybeMultipartFormRequestOptions","multipartFormRequestOptions","createForm","defaultParseResponse","props","response","options","stream","debug","status","url","headers","body","__streamClass","fromSSEResponse","controller","__binaryResponse","contentType","mediaType","split","trim","isJSON","includes","endsWith","json","_addRequestID","text","Array","isArray","Object","defineProperty","enumerable","APIPromise","Promise","constructor","responsePromise","parseResponse","resolve","_thenUnwrap","transform","asResponse","then","p","withResponse","data","all","parse","request_id","parsedPromise","onfulfilled","onrejected","catch","finally","onfinally","APIClient","baseURL","maxRetries","timeout","httpAgent","overriddenFetch","validatePositiveInteger","authHeaders","opts","defaultHeaders","Accept","getUserAgent","getPlatformHeaders","validateHeaders","customHeaders","defaultIdempotencyKey","uuid4","path","methodRequest","post","patch","put","delete","method","request","DataView","arrayBuffer","ArrayBuffer","isView","buffer","getAPIList","Page","requestAPIList","calculateContentLength","Buffer","byteLength","toString","TextEncoder","encoder","encoded","encode","length","buildRequest","retryCount","query","__binaryRequest","JSON","stringify","contentLength","buildURL","minAgentTimeout","idempotencyHeader","idempotencyKey","reqHeaders","buildHeaders","req","agent","signal","applyHeadersMut","getHeader","undefined","String","prepareOptions","prepareRequest","parseHeaders","Symbol","iterator","fromEntries","from","map","header","makeStatusError","error","message","generate","remainingRetries","makeRequest","optionsInput","retriesRemaining","aborted","AbortController","fetchWithTimeout","castToError","Error","retryRequest","name","cause","responseHeaders","createResponseHeaders","ok","shouldRetry","retryMessage","errText","e","errJSON","safeJSON","errMessage","err","PagePromise","isAbsoluteURL","URL","startsWith","slice","defaultQuery","isEmptyObj","search","stringifyQuery","entries","filter","_","key","encodeURIComponent","join","init","ms","addEventListener","abort","setTimeout","fetchOptions","toUpperCase","clearTimeout","shouldRetryHeader","timeoutMillis","retryAfterMillisHeader","timeoutMs","parseFloat","Number","isNaN","retryAfterHeader","timeoutSeconds","Date","now","calculateDefaultRetryTimeoutMillis","sleep","initialRetryDelay","maxRetryDelay","numRetries","sleepSeconds","Math","min","pow","jitter","random","AbstractPage","client","hasNextPage","items","getPaginatedItems","nextPageInfo","getNextPage","nextInfo","nextOptions","params","searchParams","iterPages","page","WeakMap","asyncIterator","item","Proxy","target","toLowerCase","requestOptionsKeys","__metadata","isRequestOptions","obj","keys","every","k","hasOwn","getPlatformProperties","Deno","build","normalizePlatform","os","normalizeArch","arch","version","deno","EdgeRuntime","process","prototype","platform","browserInfo","getBrowserInfo","browser","navigator","browserPatterns","pattern","match","exec","userAgent","major","minor","_platformHeaders","startsWithSchemeRegexp","test","n","isInteger","ensurePresent","readEnv","env","coerceInteger","round","parseInt","coerceFloat","coerceBoolean","Boolean","maybeCoerceInteger","maybeCoerceFloat","maybeCoerceBoolean","_k","hasOwnProperty","targetHeaders","newHeaders","lowerKey","val","SENSITIVE_HEADERS","Set","action","args","modifiedArgs","arg","modifiedArg","console","log","replace","c","r","v","isRunningInBrowser","window","document","isHeadersProtocol","getRequiredHeader","foundHeader","lowerCasedHeader","intercapsHeader","substring","_m","g1","g2","warn","toBase64","str","btoa","isObj"],"sources":["C:/Users/uppal/OneDrive/Desktop/financial assistant/frontend/node_modules/openai/core.mjs"],"sourcesContent":["var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _AbstractPage_client;\nimport { VERSION } from \"./version.mjs\";\nimport { Stream } from \"./streaming.mjs\";\nimport { OpenAIError, APIError, APIConnectionError, APIConnectionTimeoutError, APIUserAbortError, } from \"./error.mjs\";\nimport { kind as shimsKind, getDefaultAgent, fetch, } from \"./_shims/index.mjs\";\nimport { isBlobLike, isMultipartBody } from \"./uploads.mjs\";\nexport { maybeMultipartFormRequestOptions, multipartFormRequestOptions, createForm, } from \"./uploads.mjs\";\nasync function defaultParseResponse(props) {\n    const { response } = props;\n    if (props.options.stream) {\n        debug('response', response.status, response.url, response.headers, response.body);\n        // Note: there is an invariant here that isn't represented in the type system\n        // that if you set `stream: true` the response type must also be `Stream<T>`\n        if (props.options.__streamClass) {\n            return props.options.__streamClass.fromSSEResponse(response, props.controller);\n        }\n        return Stream.fromSSEResponse(response, props.controller);\n    }\n    // fetch refuses to read the body when the status code is 204.\n    if (response.status === 204) {\n        return null;\n    }\n    if (props.options.__binaryResponse) {\n        return response;\n    }\n    const contentType = response.headers.get('content-type');\n    const mediaType = contentType?.split(';')[0]?.trim();\n    const isJSON = mediaType?.includes('application/json') || mediaType?.endsWith('+json');\n    if (isJSON) {\n        const json = await response.json();\n        debug('response', response.status, response.url, response.headers, json);\n        return _addRequestID(json, response);\n    }\n    const text = await response.text();\n    debug('response', response.status, response.url, response.headers, text);\n    // TODO handle blob, arraybuffer, other content types, etc.\n    return text;\n}\nfunction _addRequestID(value, response) {\n    if (!value || typeof value !== 'object' || Array.isArray(value)) {\n        return value;\n    }\n    return Object.defineProperty(value, '_request_id', {\n        value: response.headers.get('x-request-id'),\n        enumerable: false,\n    });\n}\n/**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */\nexport class APIPromise extends Promise {\n    constructor(responsePromise, parseResponse = defaultParseResponse) {\n        super((resolve) => {\n            // this is maybe a bit weird but this has to be a no-op to not implicitly\n            // parse the response body; instead .then, .catch, .finally are overridden\n            // to parse the response\n            resolve(null);\n        });\n        this.responsePromise = responsePromise;\n        this.parseResponse = parseResponse;\n    }\n    _thenUnwrap(transform) {\n        return new APIPromise(this.responsePromise, async (props) => _addRequestID(transform(await this.parseResponse(props), props), props.response));\n    }\n    /**\n     * Gets the raw `Response` instance instead of parsing the response\n     * data.\n     *\n     * If you want to parse the response body but still get the `Response`\n     * instance, you can use {@link withResponse()}.\n     *\n     * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?\n     * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n     * or add one of these imports before your first `import â€¦ from 'openai'`:\n     * - `import 'openai/shims/node'` (if you're running on Node)\n     * - `import 'openai/shims/web'` (otherwise)\n     */\n    asResponse() {\n        return this.responsePromise.then((p) => p.response);\n    }\n    /**\n     * Gets the parsed response data, the raw `Response` instance and the ID of the request,\n     * returned via the X-Request-ID header which is useful for debugging requests and reporting\n     * issues to OpenAI.\n     *\n     * If you just want to get the raw `Response` instance without parsing it,\n     * you can use {@link asResponse()}.\n     *\n     *\n     * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?\n     * Try setting `\"moduleResolution\": \"NodeNext\"` if you can,\n     * or add one of these imports before your first `import â€¦ from 'openai'`:\n     * - `import 'openai/shims/node'` (if you're running on Node)\n     * - `import 'openai/shims/web'` (otherwise)\n     */\n    async withResponse() {\n        const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\n        return { data, response, request_id: response.headers.get('x-request-id') };\n    }\n    parse() {\n        if (!this.parsedPromise) {\n            this.parsedPromise = this.responsePromise.then(this.parseResponse);\n        }\n        return this.parsedPromise;\n    }\n    then(onfulfilled, onrejected) {\n        return this.parse().then(onfulfilled, onrejected);\n    }\n    catch(onrejected) {\n        return this.parse().catch(onrejected);\n    }\n    finally(onfinally) {\n        return this.parse().finally(onfinally);\n    }\n}\nexport class APIClient {\n    constructor({ baseURL, maxRetries = 2, timeout = 600000, // 10 minutes\n    httpAgent, fetch: overriddenFetch, }) {\n        this.baseURL = baseURL;\n        this.maxRetries = validatePositiveInteger('maxRetries', maxRetries);\n        this.timeout = validatePositiveInteger('timeout', timeout);\n        this.httpAgent = httpAgent;\n        this.fetch = overriddenFetch ?? fetch;\n    }\n    authHeaders(opts) {\n        return {};\n    }\n    /**\n     * Override this to add your own default headers, for example:\n     *\n     *  {\n     *    ...super.defaultHeaders(),\n     *    Authorization: 'Bearer 123',\n     *  }\n     */\n    defaultHeaders(opts) {\n        return {\n            Accept: 'application/json',\n            'Content-Type': 'application/json',\n            'User-Agent': this.getUserAgent(),\n            ...getPlatformHeaders(),\n            ...this.authHeaders(opts),\n        };\n    }\n    /**\n     * Override this to add your own headers validation:\n     */\n    validateHeaders(headers, customHeaders) { }\n    defaultIdempotencyKey() {\n        return `stainless-node-retry-${uuid4()}`;\n    }\n    get(path, opts) {\n        return this.methodRequest('get', path, opts);\n    }\n    post(path, opts) {\n        return this.methodRequest('post', path, opts);\n    }\n    patch(path, opts) {\n        return this.methodRequest('patch', path, opts);\n    }\n    put(path, opts) {\n        return this.methodRequest('put', path, opts);\n    }\n    delete(path, opts) {\n        return this.methodRequest('delete', path, opts);\n    }\n    methodRequest(method, path, opts) {\n        return this.request(Promise.resolve(opts).then(async (opts) => {\n            const body = opts && isBlobLike(opts?.body) ? new DataView(await opts.body.arrayBuffer())\n                : opts?.body instanceof DataView ? opts.body\n                    : opts?.body instanceof ArrayBuffer ? new DataView(opts.body)\n                        : opts && ArrayBuffer.isView(opts?.body) ? new DataView(opts.body.buffer)\n                            : opts?.body;\n            return { method, path, ...opts, body };\n        }));\n    }\n    getAPIList(path, Page, opts) {\n        return this.requestAPIList(Page, { method: 'get', path, ...opts });\n    }\n    calculateContentLength(body) {\n        if (typeof body === 'string') {\n            if (typeof Buffer !== 'undefined') {\n                return Buffer.byteLength(body, 'utf8').toString();\n            }\n            if (typeof TextEncoder !== 'undefined') {\n                const encoder = new TextEncoder();\n                const encoded = encoder.encode(body);\n                return encoded.length.toString();\n            }\n        }\n        else if (ArrayBuffer.isView(body)) {\n            return body.byteLength.toString();\n        }\n        return null;\n    }\n    buildRequest(options, { retryCount = 0 } = {}) {\n        options = { ...options };\n        const { method, path, query, headers: headers = {} } = options;\n        const body = ArrayBuffer.isView(options.body) || (options.__binaryRequest && typeof options.body === 'string') ?\n            options.body\n            : isMultipartBody(options.body) ? options.body.body\n                : options.body ? JSON.stringify(options.body, null, 2)\n                    : null;\n        const contentLength = this.calculateContentLength(body);\n        const url = this.buildURL(path, query);\n        if ('timeout' in options)\n            validatePositiveInteger('timeout', options.timeout);\n        options.timeout = options.timeout ?? this.timeout;\n        const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);\n        const minAgentTimeout = options.timeout + 1000;\n        if (typeof httpAgent?.options?.timeout === 'number' &&\n            minAgentTimeout > (httpAgent.options.timeout ?? 0)) {\n            // Allow any given request to bump our agent active socket timeout.\n            // This may seem strange, but leaking active sockets should be rare and not particularly problematic,\n            // and without mutating agent we would need to create more of them.\n            // This tradeoff optimizes for performance.\n            httpAgent.options.timeout = minAgentTimeout;\n        }\n        if (this.idempotencyHeader && method !== 'get') {\n            if (!options.idempotencyKey)\n                options.idempotencyKey = this.defaultIdempotencyKey();\n            headers[this.idempotencyHeader] = options.idempotencyKey;\n        }\n        const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });\n        const req = {\n            method,\n            ...(body && { body: body }),\n            headers: reqHeaders,\n            ...(httpAgent && { agent: httpAgent }),\n            // @ts-ignore node-fetch uses a custom AbortSignal type that is\n            // not compatible with standard web types\n            signal: options.signal ?? null,\n        };\n        return { req, url, timeout: options.timeout };\n    }\n    buildHeaders({ options, headers, contentLength, retryCount, }) {\n        const reqHeaders = {};\n        if (contentLength) {\n            reqHeaders['content-length'] = contentLength;\n        }\n        const defaultHeaders = this.defaultHeaders(options);\n        applyHeadersMut(reqHeaders, defaultHeaders);\n        applyHeadersMut(reqHeaders, headers);\n        // let builtin fetch set the Content-Type for multipart bodies\n        if (isMultipartBody(options.body) && shimsKind !== 'node') {\n            delete reqHeaders['content-type'];\n        }\n        // Don't set theses headers if they were already set or removed through default headers or by the caller.\n        // We check `defaultHeaders` and `headers`, which can contain nulls, instead of `reqHeaders` to account\n        // for the removal case.\n        if (getHeader(defaultHeaders, 'x-stainless-retry-count') === undefined &&\n            getHeader(headers, 'x-stainless-retry-count') === undefined) {\n            reqHeaders['x-stainless-retry-count'] = String(retryCount);\n        }\n        if (getHeader(defaultHeaders, 'x-stainless-timeout') === undefined &&\n            getHeader(headers, 'x-stainless-timeout') === undefined &&\n            options.timeout) {\n            reqHeaders['x-stainless-timeout'] = String(options.timeout);\n        }\n        this.validateHeaders(reqHeaders, headers);\n        return reqHeaders;\n    }\n    /**\n     * Used as a callback for mutating the given `FinalRequestOptions` object.\n     */\n    async prepareOptions(options) { }\n    /**\n     * Used as a callback for mutating the given `RequestInit` object.\n     *\n     * This is useful for cases where you want to add certain headers based off of\n     * the request properties, e.g. `method` or `url`.\n     */\n    async prepareRequest(request, { url, options }) { }\n    parseHeaders(headers) {\n        return (!headers ? {}\n            : Symbol.iterator in headers ?\n                Object.fromEntries(Array.from(headers).map((header) => [...header]))\n                : { ...headers });\n    }\n    makeStatusError(status, error, message, headers) {\n        return APIError.generate(status, error, message, headers);\n    }\n    request(options, remainingRetries = null) {\n        return new APIPromise(this.makeRequest(options, remainingRetries));\n    }\n    async makeRequest(optionsInput, retriesRemaining) {\n        const options = await optionsInput;\n        const maxRetries = options.maxRetries ?? this.maxRetries;\n        if (retriesRemaining == null) {\n            retriesRemaining = maxRetries;\n        }\n        await this.prepareOptions(options);\n        const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });\n        await this.prepareRequest(req, { url, options });\n        debug('request', url, options, req.headers);\n        if (options.signal?.aborted) {\n            throw new APIUserAbortError();\n        }\n        const controller = new AbortController();\n        const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);\n        if (response instanceof Error) {\n            if (options.signal?.aborted) {\n                throw new APIUserAbortError();\n            }\n            if (retriesRemaining) {\n                return this.retryRequest(options, retriesRemaining);\n            }\n            if (response.name === 'AbortError') {\n                throw new APIConnectionTimeoutError();\n            }\n            throw new APIConnectionError({ cause: response });\n        }\n        const responseHeaders = createResponseHeaders(response.headers);\n        if (!response.ok) {\n            if (retriesRemaining && this.shouldRetry(response)) {\n                const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;\n                debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders);\n                return this.retryRequest(options, retriesRemaining, responseHeaders);\n            }\n            const errText = await response.text().catch((e) => castToError(e).message);\n            const errJSON = safeJSON(errText);\n            const errMessage = errJSON ? undefined : errText;\n            const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;\n            debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);\n            const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);\n            throw err;\n        }\n        return { response, options, controller };\n    }\n    requestAPIList(Page, options) {\n        const request = this.makeRequest(options, null);\n        return new PagePromise(this, request, Page);\n    }\n    buildURL(path, query) {\n        const url = isAbsoluteURL(path) ?\n            new URL(path)\n            : new URL(this.baseURL + (this.baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));\n        const defaultQuery = this.defaultQuery();\n        if (!isEmptyObj(defaultQuery)) {\n            query = { ...defaultQuery, ...query };\n        }\n        if (typeof query === 'object' && query && !Array.isArray(query)) {\n            url.search = this.stringifyQuery(query);\n        }\n        return url.toString();\n    }\n    stringifyQuery(query) {\n        return Object.entries(query)\n            .filter(([_, value]) => typeof value !== 'undefined')\n            .map(([key, value]) => {\n            if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n                return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n            }\n            if (value === null) {\n                return `${encodeURIComponent(key)}=`;\n            }\n            throw new OpenAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);\n        })\n            .join('&');\n    }\n    async fetchWithTimeout(url, init, ms, controller) {\n        const { signal, ...options } = init || {};\n        if (signal)\n            signal.addEventListener('abort', () => controller.abort());\n        const timeout = setTimeout(() => controller.abort(), ms);\n        const fetchOptions = {\n            signal: controller.signal,\n            ...options,\n        };\n        if (fetchOptions.method) {\n            // Custom methods like 'patch' need to be uppercased\n            // See https://github.com/nodejs/undici/issues/2294\n            fetchOptions.method = fetchOptions.method.toUpperCase();\n        }\n        return (\n        // use undefined this binding; fetch errors if bound to something else in browser/cloudflare\n        this.fetch.call(undefined, url, fetchOptions).finally(() => {\n            clearTimeout(timeout);\n        }));\n    }\n    shouldRetry(response) {\n        // Note this is not a standard header.\n        const shouldRetryHeader = response.headers.get('x-should-retry');\n        // If the server explicitly says whether or not to retry, obey.\n        if (shouldRetryHeader === 'true')\n            return true;\n        if (shouldRetryHeader === 'false')\n            return false;\n        // Retry on request timeouts.\n        if (response.status === 408)\n            return true;\n        // Retry on lock timeouts.\n        if (response.status === 409)\n            return true;\n        // Retry on rate limits.\n        if (response.status === 429)\n            return true;\n        // Retry internal errors.\n        if (response.status >= 500)\n            return true;\n        return false;\n    }\n    async retryRequest(options, retriesRemaining, responseHeaders) {\n        let timeoutMillis;\n        // Note the `retry-after-ms` header may not be standard, but is a good idea and we'd like proactive support for it.\n        const retryAfterMillisHeader = responseHeaders?.['retry-after-ms'];\n        if (retryAfterMillisHeader) {\n            const timeoutMs = parseFloat(retryAfterMillisHeader);\n            if (!Number.isNaN(timeoutMs)) {\n                timeoutMillis = timeoutMs;\n            }\n        }\n        // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\n        const retryAfterHeader = responseHeaders?.['retry-after'];\n        if (retryAfterHeader && !timeoutMillis) {\n            const timeoutSeconds = parseFloat(retryAfterHeader);\n            if (!Number.isNaN(timeoutSeconds)) {\n                timeoutMillis = timeoutSeconds * 1000;\n            }\n            else {\n                timeoutMillis = Date.parse(retryAfterHeader) - Date.now();\n            }\n        }\n        // If the API asks us to wait a certain amount of time (and it's a reasonable amount),\n        // just do what it says, but otherwise calculate a default\n        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {\n            const maxRetries = options.maxRetries ?? this.maxRetries;\n            timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);\n        }\n        await sleep(timeoutMillis);\n        return this.makeRequest(options, retriesRemaining - 1);\n    }\n    calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {\n        const initialRetryDelay = 0.5;\n        const maxRetryDelay = 8.0;\n        const numRetries = maxRetries - retriesRemaining;\n        // Apply exponential backoff, but not more than the max.\n        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);\n        // Apply some jitter, take up to at most 25 percent of the retry time.\n        const jitter = 1 - Math.random() * 0.25;\n        return sleepSeconds * jitter * 1000;\n    }\n    getUserAgent() {\n        return `${this.constructor.name}/JS ${VERSION}`;\n    }\n}\nexport class AbstractPage {\n    constructor(client, response, body, options) {\n        _AbstractPage_client.set(this, void 0);\n        __classPrivateFieldSet(this, _AbstractPage_client, client, \"f\");\n        this.options = options;\n        this.response = response;\n        this.body = body;\n    }\n    hasNextPage() {\n        const items = this.getPaginatedItems();\n        if (!items.length)\n            return false;\n        return this.nextPageInfo() != null;\n    }\n    async getNextPage() {\n        const nextInfo = this.nextPageInfo();\n        if (!nextInfo) {\n            throw new OpenAIError('No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.');\n        }\n        const nextOptions = { ...this.options };\n        if ('params' in nextInfo && typeof nextOptions.query === 'object') {\n            nextOptions.query = { ...nextOptions.query, ...nextInfo.params };\n        }\n        else if ('url' in nextInfo) {\n            const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];\n            for (const [key, value] of params) {\n                nextInfo.url.searchParams.set(key, value);\n            }\n            nextOptions.query = undefined;\n            nextOptions.path = nextInfo.url.toString();\n        }\n        return await __classPrivateFieldGet(this, _AbstractPage_client, \"f\").requestAPIList(this.constructor, nextOptions);\n    }\n    async *iterPages() {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let page = this;\n        yield page;\n        while (page.hasNextPage()) {\n            page = await page.getNextPage();\n            yield page;\n        }\n    }\n    async *[(_AbstractPage_client = new WeakMap(), Symbol.asyncIterator)]() {\n        for await (const page of this.iterPages()) {\n            for (const item of page.getPaginatedItems()) {\n                yield item;\n            }\n        }\n    }\n}\n/**\n * This subclass of Promise will resolve to an instantiated Page once the request completes.\n *\n * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:\n *\n *    for await (const item of client.items.list()) {\n *      console.log(item)\n *    }\n */\nexport class PagePromise extends APIPromise {\n    constructor(client, request, Page) {\n        super(request, async (props) => new Page(client, props.response, await defaultParseResponse(props), props.options));\n    }\n    /**\n     * Allow auto-paginating iteration on an unawaited list call, eg:\n     *\n     *    for await (const item of client.items.list()) {\n     *      console.log(item)\n     *    }\n     */\n    async *[Symbol.asyncIterator]() {\n        const page = await this;\n        for await (const item of page) {\n            yield item;\n        }\n    }\n}\nexport const createResponseHeaders = (headers) => {\n    return new Proxy(Object.fromEntries(\n    // @ts-ignore\n    headers.entries()), {\n        get(target, name) {\n            const key = name.toString();\n            return target[key.toLowerCase()] || target[key];\n        },\n    });\n};\n// This is required so that we can determine if a given object matches the RequestOptions\n// type at runtime. While this requires duplication, it is enforced by the TypeScript\n// compiler such that any missing / extraneous keys will cause an error.\nconst requestOptionsKeys = {\n    method: true,\n    path: true,\n    query: true,\n    body: true,\n    headers: true,\n    maxRetries: true,\n    stream: true,\n    timeout: true,\n    httpAgent: true,\n    signal: true,\n    idempotencyKey: true,\n    __metadata: true,\n    __binaryRequest: true,\n    __binaryResponse: true,\n    __streamClass: true,\n};\nexport const isRequestOptions = (obj) => {\n    return (typeof obj === 'object' &&\n        obj !== null &&\n        !isEmptyObj(obj) &&\n        Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k)));\n};\nconst getPlatformProperties = () => {\n    if (typeof Deno !== 'undefined' && Deno.build != null) {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': normalizePlatform(Deno.build.os),\n            'X-Stainless-Arch': normalizeArch(Deno.build.arch),\n            'X-Stainless-Runtime': 'deno',\n            'X-Stainless-Runtime-Version': typeof Deno.version === 'string' ? Deno.version : Deno.version?.deno ?? 'unknown',\n        };\n    }\n    if (typeof EdgeRuntime !== 'undefined') {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': 'Unknown',\n            'X-Stainless-Arch': `other:${EdgeRuntime}`,\n            'X-Stainless-Runtime': 'edge',\n            'X-Stainless-Runtime-Version': process.version,\n        };\n    }\n    // Check if Node.js\n    if (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]') {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': normalizePlatform(process.platform),\n            'X-Stainless-Arch': normalizeArch(process.arch),\n            'X-Stainless-Runtime': 'node',\n            'X-Stainless-Runtime-Version': process.version,\n        };\n    }\n    const browserInfo = getBrowserInfo();\n    if (browserInfo) {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': VERSION,\n            'X-Stainless-OS': 'Unknown',\n            'X-Stainless-Arch': 'unknown',\n            'X-Stainless-Runtime': `browser:${browserInfo.browser}`,\n            'X-Stainless-Runtime-Version': browserInfo.version,\n        };\n    }\n    // TODO add support for Cloudflare workers, etc.\n    return {\n        'X-Stainless-Lang': 'js',\n        'X-Stainless-Package-Version': VERSION,\n        'X-Stainless-OS': 'Unknown',\n        'X-Stainless-Arch': 'unknown',\n        'X-Stainless-Runtime': 'unknown',\n        'X-Stainless-Runtime-Version': 'unknown',\n    };\n};\n// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts\nfunction getBrowserInfo() {\n    if (typeof navigator === 'undefined' || !navigator) {\n        return null;\n    }\n    // NOTE: The order matters here!\n    const browserPatterns = [\n        { key: 'edge', pattern: /Edge(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'ie', pattern: /MSIE(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'ie', pattern: /Trident(?:.*rv\\:(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'chrome', pattern: /Chrome(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'firefox', pattern: /Firefox(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'safari', pattern: /(?:Version\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?(?:\\W+Mobile\\S*)?\\W+Safari/ },\n    ];\n    // Find the FIRST matching browser\n    for (const { key, pattern } of browserPatterns) {\n        const match = pattern.exec(navigator.userAgent);\n        if (match) {\n            const major = match[1] || 0;\n            const minor = match[2] || 0;\n            const patch = match[3] || 0;\n            return { browser: key, version: `${major}.${minor}.${patch}` };\n        }\n    }\n    return null;\n}\nconst normalizeArch = (arch) => {\n    // Node docs:\n    // - https://nodejs.org/api/process.html#processarch\n    // Deno docs:\n    // - https://doc.deno.land/deno/stable/~/Deno.build\n    if (arch === 'x32')\n        return 'x32';\n    if (arch === 'x86_64' || arch === 'x64')\n        return 'x64';\n    if (arch === 'arm')\n        return 'arm';\n    if (arch === 'aarch64' || arch === 'arm64')\n        return 'arm64';\n    if (arch)\n        return `other:${arch}`;\n    return 'unknown';\n};\nconst normalizePlatform = (platform) => {\n    // Node platforms:\n    // - https://nodejs.org/api/process.html#processplatform\n    // Deno platforms:\n    // - https://doc.deno.land/deno/stable/~/Deno.build\n    // - https://github.com/denoland/deno/issues/14799\n    platform = platform.toLowerCase();\n    // NOTE: this iOS check is untested and may not work\n    // Node does not work natively on IOS, there is a fork at\n    // https://github.com/nodejs-mobile/nodejs-mobile\n    // however it is unknown at the time of writing how to detect if it is running\n    if (platform.includes('ios'))\n        return 'iOS';\n    if (platform === 'android')\n        return 'Android';\n    if (platform === 'darwin')\n        return 'MacOS';\n    if (platform === 'win32')\n        return 'Windows';\n    if (platform === 'freebsd')\n        return 'FreeBSD';\n    if (platform === 'openbsd')\n        return 'OpenBSD';\n    if (platform === 'linux')\n        return 'Linux';\n    if (platform)\n        return `Other:${platform}`;\n    return 'Unknown';\n};\nlet _platformHeaders;\nconst getPlatformHeaders = () => {\n    return (_platformHeaders ?? (_platformHeaders = getPlatformProperties()));\n};\nexport const safeJSON = (text) => {\n    try {\n        return JSON.parse(text);\n    }\n    catch (err) {\n        return undefined;\n    }\n};\n// https://url.spec.whatwg.org/#url-scheme-string\nconst startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;\nconst isAbsoluteURL = (url) => {\n    return startsWithSchemeRegexp.test(url);\n};\nexport const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\nconst validatePositiveInteger = (name, n) => {\n    if (typeof n !== 'number' || !Number.isInteger(n)) {\n        throw new OpenAIError(`${name} must be an integer`);\n    }\n    if (n < 0) {\n        throw new OpenAIError(`${name} must be a positive integer`);\n    }\n    return n;\n};\nexport const castToError = (err) => {\n    if (err instanceof Error)\n        return err;\n    if (typeof err === 'object' && err !== null) {\n        try {\n            return new Error(JSON.stringify(err));\n        }\n        catch { }\n    }\n    return new Error(err);\n};\nexport const ensurePresent = (value) => {\n    if (value == null)\n        throw new OpenAIError(`Expected a value to be given but received ${value} instead.`);\n    return value;\n};\n/**\n * Read an environment variable.\n *\n * Trims beginning and trailing whitespace.\n *\n * Will return undefined if the environment variable doesn't exist or cannot be accessed.\n */\nexport const readEnv = (env) => {\n    if (typeof process !== 'undefined') {\n        return process.env?.[env]?.trim() ?? undefined;\n    }\n    if (typeof Deno !== 'undefined') {\n        return Deno.env?.get?.(env)?.trim();\n    }\n    return undefined;\n};\nexport const coerceInteger = (value) => {\n    if (typeof value === 'number')\n        return Math.round(value);\n    if (typeof value === 'string')\n        return parseInt(value, 10);\n    throw new OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nexport const coerceFloat = (value) => {\n    if (typeof value === 'number')\n        return value;\n    if (typeof value === 'string')\n        return parseFloat(value);\n    throw new OpenAIError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nexport const coerceBoolean = (value) => {\n    if (typeof value === 'boolean')\n        return value;\n    if (typeof value === 'string')\n        return value === 'true';\n    return Boolean(value);\n};\nexport const maybeCoerceInteger = (value) => {\n    if (value === undefined) {\n        return undefined;\n    }\n    return coerceInteger(value);\n};\nexport const maybeCoerceFloat = (value) => {\n    if (value === undefined) {\n        return undefined;\n    }\n    return coerceFloat(value);\n};\nexport const maybeCoerceBoolean = (value) => {\n    if (value === undefined) {\n        return undefined;\n    }\n    return coerceBoolean(value);\n};\n// https://stackoverflow.com/a/34491287\nexport function isEmptyObj(obj) {\n    if (!obj)\n        return true;\n    for (const _k in obj)\n        return false;\n    return true;\n}\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\nexport function hasOwn(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\n/**\n * Copies headers from \"newHeaders\" onto \"targetHeaders\",\n * using lower-case for all properties,\n * ignoring any keys with undefined values,\n * and deleting any keys with null values.\n */\nfunction applyHeadersMut(targetHeaders, newHeaders) {\n    for (const k in newHeaders) {\n        if (!hasOwn(newHeaders, k))\n            continue;\n        const lowerKey = k.toLowerCase();\n        if (!lowerKey)\n            continue;\n        const val = newHeaders[k];\n        if (val === null) {\n            delete targetHeaders[lowerKey];\n        }\n        else if (val !== undefined) {\n            targetHeaders[lowerKey] = val;\n        }\n    }\n}\nconst SENSITIVE_HEADERS = new Set(['authorization', 'api-key']);\nexport function debug(action, ...args) {\n    if (typeof process !== 'undefined' && process?.env?.['DEBUG'] === 'true') {\n        const modifiedArgs = args.map((arg) => {\n            if (!arg) {\n                return arg;\n            }\n            // Check for sensitive headers in request body 'headers' object\n            if (arg['headers']) {\n                // clone so we don't mutate\n                const modifiedArg = { ...arg, headers: { ...arg['headers'] } };\n                for (const header in arg['headers']) {\n                    if (SENSITIVE_HEADERS.has(header.toLowerCase())) {\n                        modifiedArg['headers'][header] = 'REDACTED';\n                    }\n                }\n                return modifiedArg;\n            }\n            let modifiedArg = null;\n            // Check for sensitive headers in headers object\n            for (const header in arg) {\n                if (SENSITIVE_HEADERS.has(header.toLowerCase())) {\n                    // avoid making a copy until we need to\n                    modifiedArg ?? (modifiedArg = { ...arg });\n                    modifiedArg[header] = 'REDACTED';\n                }\n            }\n            return modifiedArg ?? arg;\n        });\n        console.log(`OpenAI:DEBUG:${action}`, ...modifiedArgs);\n    }\n}\n/**\n * https://stackoverflow.com/a/2117523\n */\nconst uuid4 = () => {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n        const r = (Math.random() * 16) | 0;\n        const v = c === 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n};\nexport const isRunningInBrowser = () => {\n    return (\n    // @ts-ignore\n    typeof window !== 'undefined' &&\n        // @ts-ignore\n        typeof window.document !== 'undefined' &&\n        // @ts-ignore\n        typeof navigator !== 'undefined');\n};\nexport const isHeadersProtocol = (headers) => {\n    return typeof headers?.get === 'function';\n};\nexport const getRequiredHeader = (headers, header) => {\n    const foundHeader = getHeader(headers, header);\n    if (foundHeader === undefined) {\n        throw new Error(`Could not find ${header} header`);\n    }\n    return foundHeader;\n};\nexport const getHeader = (headers, header) => {\n    const lowerCasedHeader = header.toLowerCase();\n    if (isHeadersProtocol(headers)) {\n        // to deal with the case where the header looks like Stainless-Event-Id\n        const intercapsHeader = header[0]?.toUpperCase() +\n            header.substring(1).replace(/([^\\w])(\\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());\n        for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {\n            const value = headers.get(key);\n            if (value) {\n                return value;\n            }\n        }\n    }\n    for (const [key, value] of Object.entries(headers)) {\n        if (key.toLowerCase() === lowerCasedHeader) {\n            if (Array.isArray(value)) {\n                if (value.length <= 1)\n                    return value[0];\n                console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);\n                return value[0];\n            }\n            return value;\n        }\n    }\n    return undefined;\n};\n/**\n * Encodes a string to Base64 format.\n */\nexport const toBase64 = (str) => {\n    if (!str)\n        return '';\n    if (typeof Buffer !== 'undefined') {\n        return Buffer.from(str).toString('base64');\n    }\n    if (typeof btoa !== 'undefined') {\n        return btoa(str);\n    }\n    throw new OpenAIError('Cannot generate b64 string; Expected `Buffer` or `btoa` to be defined');\n};\nexport function isObj(obj) {\n    return obj != null && typeof obj === 'object' && !Array.isArray(obj);\n}\n//# sourceMappingURL=core.mjs.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}